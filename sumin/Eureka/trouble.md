
### 🤷‍♀️ 개발 과정에서 생긴 고민점들
<br>
[목차]

[고민1. RDBMS vs NoSQL](#고민1)

[고민2. GraphQL vs Restful API](#고민2)

[고민3. Micro Service Architecutre](#고민3)

[고민4. MAS에서의 트랜젝션](#고민4)



<br><br><br><br>

##### 고민1)
## RDBMS vs NoSQL

#### RDBMS 특징
- Data를 Column과 Row의 이차원 배열 형태로 저장
- SQL(Structured Query Language) 쿼리로 데이터 다룸
- Transaction (작업의 완전성 보장)
- 데이터의 분류, 정렬, 탐색 속도가 비교적 빠름
- MySQL, SQLite, OracleDB

	##### 장점
	- 데이터 중복이 없어 공간 절약
	- 데이터 구조가 명확
	- 작업의 완전성 보장


	##### 단점
	- Oracle의 경우 비용 부담이 크다
	- 시스템이 복잡해 질수록 쿼리문이 복잡하고 성능이 저하된다.
	- 데이터 처리에 대한 부하 발생시, 처리 어려움
<br>

#### NoSQL 특징
- 컬렉션 형태로 데이터 관리(테이블 ≒ 컬렉션)
- 데이터 형태, 스키마  정의하지 않음 (join 불가)
- Key에 대한 put/get만 지원
- 대용량 데이터 관리 용이
- 분산형 구조 : 데이터를 여러 대의 서버에 분산해 저장
- MongoDB, Cassandra, Redis

	##### 장점
	- 수평적 확장이 상대적으로 쉬움
	- 필요한 데이터가 하나의 컬렉션에 존재
	- 위치 정보를 다루기 쉽다(MongoDB - KNN쿼리)
	- Data-driven한 개발이 가능(복잡한 구조의 데이터인데 활용도가 명확하게 정해지지 않았다면, 데이터를 넣고 인덱스를 나중에 걸어 활용할 수 있다.)

	##### 단점
	- 자유롭게 데이터 추가가 가능해 중복 데이터 관리 필요
	- Update 비교적 느림

<br>


### 대용량 트래픽을 감당하기 위해서는?

#### RDBMS로도 충분히 가능하다!
##### 해결책 >  /////////이부분 각각 정리하기
1. 기본적인 튜닝 (정규화, 인덱싱)
2. 캐싱
3. Read-only 리플리케이션
4. 샤딩
5. 미들웨어 투입
6. 테이블 설계 단순화
7. 부분적 NoSQL 활용
 
### 결론, 
데이터가 단순하다면 MySQL

위치 정보를 많이 다룬다면 몽고디비

데이터베이스를 깊이 있게 배워가면서 할 생각이 있다면 PostgreSQL

  

<br><br><br>
##### 고민2)
## GraphQL vs Restful API

#### Restful API

#### GraphQL  

restful API는 각 엔드포인트별 자원/모델에 종속적

그래프큐엘은 경계를 없애고 클라이언트 주도로 API사영 가능
서버에서는 스키마 정의, 보안, 서버 코어 로직에 대한 처리만 하고 클라이언트에서 주도적으로 데이터에 접근하여 읽고 씀

  
<br><br><br>
##### 고민3)
## Micro Service Architecture

<b>Micro Service Architecture(이하 MSA)</b>는 
"전체 어플리케이션을 특정 목적을 가진 어플리케이션 단위로 쪼개는 방식"
을 말한다.
프로젝트 전체가 하나의 어플리케이션으로 이루어진 Monolitic Architecture의 단점인 기능간의 의존성을 해결할 수 있는 방식이다. 

최근 많은 기업들에서 MSA를 적용하고 있고, 채용 공고에서도
> MSA로의 전환 개발한 경험을 보유하신 분

이와 같은 문구를 쉽게 찾아볼 수 있다.

<br>

### MSA를 사용하는 이유
모놀리틱 아키텍쳐 서버인 경우 컴포넌트별로 유연한 기술 도입이 어렵다.  
수많은 소스코드 중 한 부분에서 오류가 나도 전체 서비스가 중단되게 된다. 또한, 볼륨이 커지면서 빌드, 배포가 오래걸릴 뿐만 아니라 재배포 하는 동안 모든 서비스가 중단된다. 

 <b>즉, 대용량 웹서비스의 경우에 불편함이 발생한다.</b>

이런 불편함을 해소하고자 MSA는 각 컴포넌트를 <b>Service</b>로 정의한다.
>  Service : 데이터부터 비즈니스 로직까지 독립적인 컴포넌트

서비스의 경계는 업무의 경계를 따른다. 

> Eureka의 경우 사용자 관리, 관리자 관리, 상품 관리, 주문 관리, 리뷰 관리, 파일 관리, 인증 관리 등의 기능으로 구분할 수 있다.
 
<br>
<b>데이터의 분리</b>

기존의 중앙집중식의 DBMS와 달리 MSA는 각 서비스별로 데이터베이스를 가진다.  
-> 수직분할원칙(Vertical Slicing)

> 다른 컴포넌트의 데이터를 필요로 하는 경우에는 컴포넌트간의 API 통신이 필요하기 때문에 성능 저하나 트랜젝션 처리 문제가 발생한다. 
> 
<br>
<b>배포 분리</b>

배포시에 각 컴포넌트는 독립적인 서버로 배포된다.

이는 컴포넌트별로 서버 인스턴스를 관리할 수 있기 때문에, scale-out이 가능해진다.

<br><br>
### API Gateway

MSA는 각 컴포넌트가 별도의 서버이기 때문에 서버 URL이 분리되어있다. 

이것은,
- 수많은 API 호출 관리의 어려움
- 클라이언트에서 매번 다른 서버를 호출해야함
- 내부 비즈니스 로직이 드러나 보안에 취약
- 각 서비스마다 인증과 같은 공통 로직을 중복 구현


의 단점을 가진다.


**이러한 단점을 해결하기 위해 API Gateway를 필요로 한다.**

#### API Gateway의 기능
1. 인증 서비스
2. Routing과 Load Balancing
3. Service Discovery
	각 서비스 고유의 ip주소와 포트번호를 찾는 기능
	
	이러한 기능을 제공하는 서비스 레지스트리
	> Netflix Eureka,  Apache ZooKeeper,  etcd,  consul
  
    <br>
	로드 밸런싱을 하게 되면 
	
	> 클라우드 서비스의 경우 잦은 scale-up/down이 발생하는데 그에 따라 컨테이너가 생성/소멸되고, ip주소와 포트번호가 달라지기 때문에 필수적인 기능이다.


<br><br>
### Circuit Breaker
A서비스에서 B서비스를 호출하는 로직이 있다. 만약, B서비스에서 인스턴스가 느려지거나 장애가 발생하면, 이는  A서비스에도 똑같이 적용되는데 이를 **전파**라고 한다. 이러한 문제를 해결하기 위해서 **Circuit Breaker**를 사용한다.

서비스간의 호출 중간에 추가적으로 컴포넌트를 두어 요청할 서비스의 상태를 미리 알아보고, 서버가 정상적인 상태가 아니면 오류를 반환시킨다.

**대표적인 circuit breaker service**
> Netflix의  Hystrix, Spring Cloud의 SpringCircuit Breaker



<br><br><br>
##### 고민4)
## MSA에서의 트랜젝션

단일 DB를 가진 Monolithic Architecture 서버는 DB에서 제공하는 Commit, Rollback을 이용하여 데이터를 일관성있게 제어할 수 있다.
하지만, MSA는 각 서비스 별로 인스턴스와 데이터베이스가 분리되어 있어 DB의 트랜젝션 기능을 사용할 수 없고, 데이터의 일관성과 원자성을 보장받을 수 없다.

두 개 이상의 어플리케이션 혹은 분리되어 있 는 서비스가 각각의 데이터베이스를 가진 경우,
1. Two-Phase Commit 
2. Saga 패턴
https://blog.neonkid.xyz/243?category=830544


