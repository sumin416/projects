# HTTP란?

### Hyper Text Transfer Protocol

### W3 상에서 정보를 주고받을 수 있는 프로토콜이다.

### HTML 문서와 같은 리소스들을 가져온다.

### 주로 TCP를 사용하고, HTTP/3 부터는 UDP를 사용한다.

### 80번 포트

### Request / Response 프로토콜

### 요청 메시지

1.  요청 내용
    
    GET /images/logo.gif HTTP/1.1
    
    (메서드, 리소스, 프로토콜 및 버전)
    

(요청 내용과 헤더 필드는 <CR><LF>로 끝나야 한다.

1.  헤더
    
    Accept-Language: en
    
2.  빈줄
    
3.  기타 메시지를 포함한다.
    

### 응답 메시지

1.  상태표시 행
    
    HTTP/1.1 200 OK
    
    (프로토콜 및 버전, 상태코드, 결과 메시지)
    
2.  응답 헤더필드
    
    Content-Type: text/html
    
3.  빈줄
    
4.  기타 메시지
    

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63038d53-3349-4316-ae60-7b31ec0f2bac/http.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63038d53-3349-4316-ae60-7b31ec0f2bac/http.png)

HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 무서 뿐 아니라 이미지와 비디오 혹은 HTML 폼 결과와 같은 내용을 서버로 POST하기 위해서도 사용된다.

실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재. : 라우터, 모뎀 등.

웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨진다.

HTTP는 애플리케이션 계층의 최상위에 존재.

### 사용자 에이전트

사용자를 대신하여 동작하는 모든 도구 : 브라우저

*브라우저는 항상 요청을 보내는 개체. 결코 서버가 될 수 없다.

웹 페이지를 표시하기 위해 브라우저는 페이지의 HTML을 가져오기 위한 요청을 전송 - 파일을 구문 분석하여 실행해야 할 스크립트, 페이지 내 포함된 리소스(이미지, 비디오...)를 잘 표시하기 위한 레이아웃 정보(CSS)에 대응하는 추가적인 요청들을 가져온다.

완전한 웹 페이지를 표시하기 위해 리소스들을 혼합.

스크립트는 이후 단계에서 좀 더 많은 리소스를 가져오고, 이에 웹 페이지를 갱신.

### 웹 서버

요청에 대한 문서를 제공.

서버는 사실상 논리적으로 단일 기계. 이는 로드 밸런싱, 캐시, DB서버, e-커머스 서버등과 같은 다른 컴퓨터들의 정보를 얻고 완전하게, 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합일 수도 있기 때문

HTTP/1.1과 Host 헤더를 이용하여, 동일한 ip주소를 공유할 수 있다

### 프록시

웹 브라우저와 서버 사이에는 수많은 컴퓨터와 머신이 HTTP 메시지를 이어 받고 전달한다.

이러한 머신들은 대부분 전송, 네트워크 혹은 물리 계층에서 동작

성능에 상당히 큰 영향을 주지만, HTTP 계층에서는 눈에 보이지 않는다.

이러한 머신 중에서도 애플리케이션 계층에서 동작하는 것들을 일반적으로 **프록시**라 부른다.

-   캐싱(캐시는 공개 또는 비공개가 될 수 있다(예: 브라우저 캐시))
-   필터링(바이러스 백신 스캔, 유해 컨텐츠 차단(자녀 보호) 기능)
-   로드 밸런싱(여러 서버들이 서로 다른 요청을 처리하도록 허용)
-   인증(다양한 리소스에 대한 접근 제어)
-   로깅(이력 정보를 저장)

### HTTP의 기초적인 측면

-   HTTP는 사람이 읽을 수 있다
-   간단하다.
-   확장 가능 → HTTP 헤더는 HTTP를 확장하고 실험하기 쉽게 만들어줌
-   Stateless, 그러나 HTTP 쿠키는 상태가 있는 세션을 만들도록 한다.
-   각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

### HTTP와 연결

연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖이다.

여러 요청을 연속해서 보내는 경우, 단일 TCP연결을 공유하는 것보다 비효율적이다 - Request/Response마다 별도의 TCP연결을 열기 때문

이러한 결함을 개선하기 위해 HTTP/1.1은 파이프라이닝 개념과 지속적인 연결의 개념을 도입.

기본적인 TCP 연결은 Connection 헤더를 사용해 부분적으로 제어할 수 있습니다.

HTTP/2는 연결을 좀 더 지속되고 효율적으로 유지하는데 도움이 되도록, 단일 연결 상에서 메시지를 다중 전송하여(multiplex) 한 걸음 더 나아갔다.

구글은 좀 더 신뢰성있고 효율적인 전송 프로토콜을 제공하기 위해 UDP 기반의 QUIC를 실험 중에 있다.

### HTTP로 제어할 수 있는 것.

-   캐시 : 서버는 캐시 대상과 기간을 프록시와 클라이언트에 지시할 수 있고, 클라이언트는 저장된 문서를 무시하라고 중간 캐시 프록시에게 지시할 수 있다.
-   origin 제약사항을 완화시키는 조치 : 스누핑, 프라이버시 침해를 막기 위해 브라우저는 웹 사이트간 엄격한 분리를 강제. 그러나 HTTP 헤더를 통해 완화 가능.(보안과 관련된 사항이 있을 수 있음)
-   인증 : Authenticate 헤더값 또는 HTTP 쿠키를 사용한 특정 세션을 설정하여 이루어진다.
-   세션 : 쿠키 사용은 서버 상태를 요청과 연결하도록 해준다. 이것은 e-커머스 쇼핑 바구니를 위해 유용하다. 사용자 구성을 허용하는 모든 사이트에 대해 유용하다.

### HTTP 흐름

1.  TCP 연결. 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 여러 TCP 연결을 열 수 있다.
2.  HTTP 메시지를 전송한다.
3.  서버에 의해 전송된 응답을 읽는다.
4.  연결을 닫거나 다른 요청들을 위해 재사용한다.

HTTP 파이프라이닝이 활성화되면, 여러 요청을 응답 수신을 기다리지 않고 보낼 수 있다.

### HTTP 메시지

-   사람이 읽을 수 있다.

### HTTP 기반 API

-   XMLHttpRequest API
-   Fetch API는 보다 강력하고 유연한 기능을 제공

### 결론

-   HTTP는 쉬운 확장 - 헤더를 쉽게 추가
